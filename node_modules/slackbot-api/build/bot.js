'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createDecoratedClass = (function () { function defineProperties(target, descriptors, initializers) { for (var i = 0; i < descriptors.length; i++) { var descriptor = descriptors[i]; var decorators = descriptor.decorators; var key = descriptor.key; delete descriptor.key; delete descriptor.decorators; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor || descriptor.initializer) descriptor.writable = true; if (decorators) { for (var f = 0; f < decorators.length; f++) { var decorator = decorators[f]; if (typeof decorator === 'function') { descriptor = decorator(target, key, descriptor) || descriptor; } else { throw new TypeError('The decorator for method ' + descriptor.key + ' is of the invalid type ' + typeof decorator); } } if (descriptor.initializer !== undefined) { initializers[key] = descriptor; continue; } } Object.defineProperty(target, key, descriptor); } } return function (Constructor, protoProps, staticProps, protoInitializers, staticInitializers) { if (protoProps) defineProperties(Constructor.prototype, protoProps, protoInitializers); if (staticProps) defineProperties(Constructor, staticProps, staticInitializers); return Constructor; }; })();

var _get = function get(_x10, _x11, _x12) { var _again = true; _function: while (_again) { var object = _x10, property = _x11, receiver = _x12; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x10 = parent; _x11 = property; _x12 = receiver; _again = true; desc = parent = undefined; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

exports.messageMethods = messageMethods;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _modifiers = require('./modifiers');

var _modifiers2 = _interopRequireDefault(_modifiers);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _ws = require('ws');

var _ws2 = _interopRequireDefault(_ws);

var _unirest = require('unirest');

var _unirest2 = _interopRequireDefault(_unirest);

var _attachments = require('./attachments');

var _attachments2 = _interopRequireDefault(_attachments);

var _command = require('./command');

var _command2 = _interopRequireDefault(_command);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _methods = require('./methods');

var _methods2 = _interopRequireDefault(_methods);

var API = 'https://slack.com/api/';
var START_URI = 'https://slack.com/api/rtm.start';
var PING_INTERVAL = 1000;

var id = 0;

var fullExec = function fullExec(regex, string) {
  if (!regex.global) return regex.exec(string);

  var next = regex.exec(string);
  var match = [];
  var lastIndex = -1;

  while (next && regex.lastIndex !== lastIndex) {
    lastIndex = regex.lastIndex;

    match = match.concat(next.slice(1));

    next = regex.exec(string);
  }

  return match;
};

exports.fullExec = fullExec;
/**
 * A set of methods which are set on message objects before emitting events.
 * These methods are simpler forms of bot methods which prefill the message
 * parameters
 * @param  {Bot}    bot bot instance, used as context when binding functions
 * @param  {Object} msg message object, used to prefill the methods
 * @return {Object}
 */

function messageMethods(bot) {
  return {
    reply: function reply() {
      var _bot$sendMessage;

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return (_bot$sendMessage = bot.sendMessage).call.apply(_bot$sendMessage, [bot, this.channel].concat(args));
    },
    react: function react() {
      var _bot$react;

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      return (_bot$react = bot.react).call.apply(_bot$react, [bot, this.channel, this.ts].concat(args));
    },
    update: function update() {
      var _bot$updateMessage;

      for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return (_bot$updateMessage = bot.updateMessage).call.apply(_bot$updateMessage, [bot, this.channel, this.ts].concat(args));
    },
    'delete': function _delete() {
      var _bot$deleteMessage;

      for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      return (_bot$deleteMessage = bot.deleteMessage).call.apply(_bot$deleteMessage, [bot, this.channel, this.ts].concat(args));
    },
    on: function on(event, listener) {
      bot.messageListeners.push({ event: event, listener: listener, ts: this.ts, channel: this.channel });
    },
    off: function off(event, listener) {
      var index = bot.messageListeners.findIndex(function (a) {
        return a.event === event && a.listener === listener;
      });

      bot.messageListeners.splice(index, 1);
    }
  };
}

var Bot = (function (_EventEmitter) {
  _inherits(Bot, _EventEmitter);

  /**
   * Takes a config object passed to `rtm.start`,
   * see https://api.slack.com/methods/rtm.start
   *
   * @param  {object}  config
   * @param  {boolean} manual  doesn't request websocket url and `.connect`
   *                           automatically
   */

  function Bot(config, manual) {
    var _this = this;

    _classCallCheck(this, Bot);

    _get(Object.getPrototypeOf(Bot.prototype), 'constructor', this).call(this);

    (0, _command2['default'])(this);

    this.config = config;

    this.modifiers = _modifiers2['default'];

    this.Attachments = _attachments2['default'];

    this.globals = {
      websocket: true
    };

    this.listeners = [];

    this.messageListeners = [];

    this.waitForReplyTimeout = config.waitForReplyTimeout || 5000;
    this.setMaxListeners(config.maxListeners || 50);

    this.pingInterval = config.pingInterval || PING_INTERVAL;

    this.queue = [];

    /* istanbul ignore if */
    if (!manual) {
      this.connect();
    }

    this.on('user_change', function (message) {
      var user = _this.find(message.user.id);
      Object.assign(user, message.user);
    });

    this.on('message_changed', function (message) {
      var newMessage = _extends({}, message.message, { channel: message.channel });

      var update = _this.messageListeners.filter(function (a) {
        return a.ts === newMessage.ts && a.channel === newMessage.channel;
      }).filter(function (a) {
        return a.event === 'update';
      });

      update.forEach(function (_ref) {
        var listener = _ref.listener;
        return listener(newMessage);
      });
    });

    this.on('message_deleted', function (message) {
      var deleted = _this.messageListeners.filter(function (a) {
        return a.ts === message.ts && a.channel === message.channel;
      }).filter(function (a) {
        return a.event === 'delete';
      });

      deleted.forEach(function (_ref2) {
        var listener = _ref2.listener;
        return listener(message);
      });
    });

    this.on('reaction_added', function (message) {
      var item = message.item;

      var reacted = _this.messageListeners.filter(function (a) {
        return a.ts === item.ts && a.channel === item.channel;
      }).filter(function (a) {
        return a.event === 'reaction_added';
      });

      reacted.forEach(function (_ref3) {
        var listener = _ref3.listener;
        return listener(message);
      });
    });

    this.on('reaction_removed', function (message) {
      var item = message.item;

      var removed = _this.messageListeners.filter(function (a) {
        return a.ts === item.ts && a.channel === item.channel;
      }).filter(function (a) {
        return a.event === 'reaction_removed';
      });

      removed.forEach(function (_ref4) {
        var listener = _ref4.listener;
        return listener(message);
      });
    });

    ['channel_created', 'group_joined', 'im_created'].forEach(function (ev) {
      return _this.on(ev, function (message) {
        var model = ev.split('_')[0];
        var key = model + 's';
        _this[key].push(message.channel);
      });
    });

    this.on('message', function callee$2$0(message) {
      var preformatted, NAME, mention, text, ascii, hasListener, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _loop, _iterator, _step, _ret;

      return regeneratorRuntime.async(function callee$2$0$(context$3$0) {
        var _this2 = this;

        while (1) switch (context$3$0.prev = context$3$0.next) {
          case 0:
            if (!(message.subtype || !message.text)) {
              context$3$0.next = 2;
              break;
            }

            return context$3$0.abrupt('return');

          case 2:
            if (!(message.user && message.user.startsWith('B'))) {
              context$3$0.next = 4;
              break;
            }

            return context$3$0.abrupt('return');

          case 4:
            message.text = message.text.trim();

            // preformat the text
            preformatted = message.text.replace(/<@([^>]+)>/g, function (a, user) {
              return '@' + _this2.find(user).name;
            }).replace(/<#([^>]+)>/g, function (a, channel) {
              return '#' + _this2.find(channel).name;
            }).replace(/<((?:http|https):\/\/[^>]+)>/g, function (a, url) {
              return url;
            }).replace(/&gt;/g, '>').replace(/&lt;/g, '<').replace(/&amp;/g, '&');
            NAME = new RegExp('@?\\b' + this.self.name + '\\b:?', 'i');
            mention = message.channel.startsWith('D') || NAME.test(preformatted) || message.mention;
            text = preformatted.replace(NAME, '').trim();
            ascii = _lodash2['default'].deburr(text);

            message.preformatted = preformatted;
            message.mention = mention;

            hasListener = false;
            _iteratorNormalCompletion = true;
            _didIteratorError = false;
            _iteratorError = undefined;
            context$3$0.prev = 16;

            _loop = function callee$3$0() {
              var _step$value, listener, regex, params;

              return regeneratorRuntime.async(function callee$3$0$(context$4$0) {
                var _this3 = this;

                while (1) switch (context$4$0.prev = context$4$0.next) {
                  case 0:
                    _step$value = _step.value;
                    listener = _step$value.listener;
                    regex = _step$value.regex;
                    params = _step$value.params;

                    if (!(params.mention && !mention)) {
                      context$4$0.next = 6;
                      break;
                    }

                    return context$4$0.abrupt('return', 'continue');

                  case 6:
                    if (!(text && regex.test(text) || ascii && regex.test(ascii))) {
                      context$4$0.next = 9;
                      break;
                    }

                    context$4$0.next = 9;
                    return regeneratorRuntime.awrap((function callee$4$0() {
                      var msg;
                      return regeneratorRuntime.async(function callee$4$0$(context$5$0) {
                        while (1) switch (context$5$0.prev = context$5$0.next) {
                          case 0:
                            msg = _extends({}, message, { ascii: ascii });
                            // clone

                            regex.lastIndex = 0;
                            msg.match = fullExec(regex, text);
                            regex.lastIndex = 0;
                            msg.asciiMatch = fullExec(regex, ascii);

                            context$5$0.prev = 5;
                            context$5$0.next = 8;
                            return regeneratorRuntime.awrap(_modifiers2['default'].trigger('hear', _extends({}, msg, params)).then(function () {
                              // eslint-disable-line
                              if (!params.matchAll) hasListener = true;
                              return listener(msg);
                            }));

                          case 8:
                            context$5$0.next = 13;
                            break;

                          case 10:
                            context$5$0.prev = 10;
                            context$5$0.t0 = context$5$0['catch'](5);

                            if (this.config.debug) console.error('Modifier `hear` interrupted: ', context$5$0.t0);

                          case 13:
                          case 'end':
                            return context$5$0.stop();
                        }
                      }, null, _this3, [[5, 10]]);
                    })());

                  case 9:
                  case 'end':
                    return context$4$0.stop();
                }
              }, null, _this2);
            };

            _iterator = this.listeners[Symbol.iterator]();

          case 19:
            if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {
              context$3$0.next = 28;
              break;
            }

            context$3$0.next = 22;
            return regeneratorRuntime.awrap(_loop());

          case 22:
            _ret = context$3$0.sent;

            if (!(_ret === 'continue')) {
              context$3$0.next = 25;
              break;
            }

            return context$3$0.abrupt('continue', 25);

          case 25:
            _iteratorNormalCompletion = true;
            context$3$0.next = 19;
            break;

          case 28:
            context$3$0.next = 34;
            break;

          case 30:
            context$3$0.prev = 30;
            context$3$0.t0 = context$3$0['catch'](16);
            _didIteratorError = true;
            _iteratorError = context$3$0.t0;

          case 34:
            context$3$0.prev = 34;
            context$3$0.prev = 35;

            if (!_iteratorNormalCompletion && _iterator['return']) {
              _iterator['return']();
            }

          case 37:
            context$3$0.prev = 37;

            if (!_didIteratorError) {
              context$3$0.next = 40;
              break;
            }

            throw _iteratorError;

          case 40:
            return context$3$0.finish(37);

          case 41:
            return context$3$0.finish(34);

          case 42:

            if (!hasListener) {
              this.emit('notfound', message);
            }

          case 43:
          case 'end':
            return context$3$0.stop();
        }
      }, null, _this, [[16, 30, 34, 42], [35,, 37, 41]]);
    });

    function initPing() {
      var _this4 = this;

      clearInterval(this.pingIntv);
      this.pingIntv = setInterval(function () {
        _this4.call('ping', {}, true);
      }, this.pingInterval);
    }
    this.on('open', initPing);

    this.api = {};
    _methods2['default'].forEach(function (method) {
      _lodash2['default'].set(_this.api, method, _this.call.bind(_this, method));
    });
  }

  /**
   * Inject a request, used for testing
   * The method has some good defaults to reduce the overhead of specifying all properties
   * of an event data
   * @param  {String} event the event to trigger
   * @param  {Object}       data  the data to emit the event with
   */

  _createDecoratedClass(Bot, [{
    key: 'inject',
    value: function inject(events, data) {
      var _this5 = this;

      data = _lodash2['default'].defaults(data, {
        user: 'U123456',
        ts: '1355517523.000005'
      });

      switch (events) {
        case 'message':
          data = _lodash2['default'].defaults(data, {
            type: 'message',
            channel: 'C123456',
            text: 'Hello World'
          });
          break;

        case 'bot_message':
        case 'me_message':
        case 'channel_join':
        case 'channel_leave':
        case 'channel_topic':
        case 'channel_purpose':
        case 'channel_name':
        case 'channel_archive':
        case 'channel_unarchive':
        case 'group_join':
        case 'group_leave':
        case 'group_topic':
        case 'group_purpose':
        case 'group_name':
        case 'group_archive':
        case 'group_unarchive':
        case 'file_share':
        case 'file_comment':
        case 'file_mention':
        case 'pinned_item':
        case 'unpinned_item':
          data = _lodash2['default'].defaults(data, {
            type: 'message',
            subtype: events,
            channel: 'C123456',
            text: 'Hello World'
          });
          events = [events, 'message'];
          break;

        case 'message_deleted':
          data = _lodash2['default'].defaults(data, {
            type: 'message',
            subtype: events,
            channel: 'C123456',
            hidden: true,
            deleted_ts: '1355517523.000005'
          });
          events = [events, 'message'];
          break;

        case 'message_changed':
          data = _lodash2['default'].defaults(data, {
            type: 'message',
            subtype: events,
            channe: 'C123456',
            hidden: true,
            message: {
              type: 'message',
              user: 'U123456',
              text: 'Hello World',
              ts: '1355517523.000002',
              edited: {
                user: 'U123456',
                ts: '1355517523.000005'
              }
            }
          });
          events = [events, 'message'];
          break;
        default:
          break;
      }

      (Array.isArray(events) ? events : [events]).forEach(function (ev) {
        Object.assign(data, messageMethods(_this5));

        if (data.message) {
          data.message.channel = data.channel;

          var subMethods = messageMethods(_this5);
          Object.assign(data.message, subMethods);
        }

        _this5.emit(ev, data);
      });

      return data;
    }

    /**
     * Tries to re-connect to server
     */
  }, {
    key: 'reconnect',
    decorators: [(0, _modifiers.processable)('reconnect')],
    value: function reconnect() {
      if (this.dead) return;

      var ws = this.ws;

      if (ws.readyState === _ws2['default'].CONNECTING || ws.readyState === _ws2['default'].OPEN) {
        return;
      }

      this.connect(this.url, true);
    }

    /**
     * Creates a WebSocket connection to the slack API url
     * @param  {String} url slack bot's API url e.g. wss://xyz
     * @param {Boolean} reconnect indicates a reconnection, not an initial connection
     * @return {Promise}    A promise which resolves upon `open`
     */
  }, {
    key: 'connect',
    decorators: [(0, _modifiers.processable)('connect')],
    value: function connect(url, reconnect) {
      var ws;
      return regeneratorRuntime.async(function connect$(context$2$0) {
        var _this6 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            console.log('[slackbot-api] connecting...');

            if (!this.dead) {
              context$2$0.next = 3;
              break;
            }

            return context$2$0.abrupt('return');

          case 3:
            this.url = url;

            if (url) {
              context$2$0.next = 7;
              break;
            }

            context$2$0.next = 7;
            return regeneratorRuntime.awrap(new Promise(function (resolve, reject) {
              _unirest2['default'].get(START_URI + '?token=' + _this6.config.token).headers({ Accept: 'application/json' }).end(function (response) {
                var data = response.body;

                if (!data || !data.url || response.error) {
                  return reject(new Error('Error connecting to Slack.'));
                }

                url = data.url;
                delete data.ok;
                delete data.url;
                Object.assign(_this6, data);
                Object.assign(_this6.self, _this6.find(_this6.self.id));

                resolve();
              });
            }));

          case 7:

            if (this.ws) {
              this.ws.terminate();
              delete this.ws;
            }

            this.ws = new _ws2['default'](url);
            ws = this.ws;

            ws.on('close', function () {
              console.log('[slackbot-api] websocket closed');
              _this6.reconnect();
            });

            return context$2$0.abrupt('return', new Promise(function (resolve) {
              ws.on('open', function () {
                console.log('[slackbot-api] websocket opened');
                _this6.queue.forEach(_this6.call);
                _this6.queue = [];

                if (reconnect) {
                  _this6.emit('reconnect');
                } else {
                  _this6.emit('open');
                }

                resolve();

                ws.on('message', function (message) {
                  var msg = undefined;
                  try {
                    msg = JSON.parse(message);
                  } catch (e) {
                    console.error('Error parsing received message', message);
                    return;
                  }

                  if (msg.type === 'error') {
                    console.error('Error Message Received:', msg);
                    return;
                  }

                  Object.assign(msg, messageMethods(_this6));

                  if (msg.message) {
                    msg.message.channel = msg.channel;

                    var subMethods = messageMethods(_this6);
                    Object.assign(msg.message, subMethods);
                  }

                  _this6.emit('raw_message', msg);
                  _this6.emit(msg.type, msg);
                  _this6.emit(msg.subtype, msg);
                });
              });
            }));

          case 12:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Find a User | Channel | Group | IM | Bot by it's name or ID
     * @param  {String} name target name
     * @return {Object}      channel, group, im, user or the bot
     *                                matching the specified name or id
     */
  }, {
    key: 'find',
    decorators: [(0, _modifiers.processable)('find')],
    value: function find(name) {
      if (this.type(name) === 'ID') {
        return this.all().find(function (item) {
          return item.id === name;
        });
      }

      return this.all().find(function (item) {
        return item.name === name;
      });
    }

    /**
     * Return an array containing all users, channels, groups, IMs and bots
     * @return {Array}
     */
  }, {
    key: 'all',
    decorators: [(0, _modifiers.processable)('all')],
    value: function all() {
      return this.users.concat(this.groups).concat(this.channels).concat(this.ims).concat(this.bots);
    }

    /**
     * Listens on incoming messages matching a regular expression or
     * @param  {regexp}   regex    regular expression to match messages against
     * @param  {function} listener the listener, invoked upon a matching message
     * @param  {object}   params
     * @return {bot}                returns the bot itself
     */
  }, {
    key: 'hear',
    decorators: [(0, _modifiers.processable)('hear')],
    value: function hear(regex, listener) {
      var params = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      if (typeof regex === 'function') {
        listener = regex;
        params = listener;
        regex = /./;
        params.matchAll = true;
      }

      this.listeners.push({ regex: regex, listener: listener, params: params });

      return this;
    }

    /**
     * Listens on incoming messages mentioning the bot, messages are matched only
     * if the message contains bot's name
     * @param  {regexp}   regex    optional: regular expression to match messages
     *                             against. default: /./
     * @param  {function} listener the listener, invoked upon a matching message
     * @param  {object}   params
     * @return {bot}                returns the bot itself
     */
  }, {
    key: 'listen',
    decorators: [(0, _modifiers.processable)('listen')],
    value: function listen(regex, listener) {
      var params = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      params.mention = true;

      return this.hear(regex, listener, params);
    }

    /**
     * Send a message to IM | Channel | Group
     * @param  {String|Array} channel The channel, im or group to send the message to
     * @param  {String} text          Message's text content
     * @param  {Object} params        Message's parameters
     *                                see https://api.slack.com/methods/chat.postMessage
     * @return {Promise}              A promise which resolves upon succes and fails
     *                                in case of errors
     */
  }, {
    key: 'sendMessage',
    decorators: [(0, _modifiers.processable)('sendMessage')],
    value: function sendMessage(channel, text) {
      var params = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];
      var options, target, msg, method;
      return regeneratorRuntime.async(function sendMessage$(context$2$0) {
        var _this7 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!Array.isArray(channel)) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return', Promise.all(channel.map(function (ch) {
              return _this7.sendMessage(ch, text, params);
            })));

          case 2:
            options = _extends({}, this.globals, params);
            target = undefined;

            if (!(channel[0] === '@')) {
              context$2$0.next = 9;
              break;
            }

            target = channel;
            options.websocket = false;
            context$2$0.next = 15;
            break;

          case 9:
            if (!(this.type(channel) === 'ID')) {
              context$2$0.next = 13;
              break;
            }

            target = channel;
            context$2$0.next = 15;
            break;

          case 13:
            context$2$0.next = 15;
            return regeneratorRuntime.awrap((function callee$2$0() {
              var ch, im;
              return regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    ch = (this.find(channel) || {}).id;

                    if (!(ch && ch[0] === 'U')) {
                      context$3$0.next = 13;
                      break;
                    }

                    im = (this.ims.find(function (i) {
                      return i.user === ch;
                    }) || {}).id;

                    if (im) {
                      context$3$0.next = 10;
                      break;
                    }

                    context$3$0.next = 6;
                    return regeneratorRuntime.awrap(this.call('im.open', { user: ch }));

                  case 6:
                    im = context$3$0.sent;

                    target = im && im.channel ? im.channel.id : null;
                    context$3$0.next = 11;
                    break;

                  case 10:
                    target = im;

                  case 11:
                    context$3$0.next = 14;
                    break;

                  case 13:
                    target = ch;

                  case 14:
                    if (target) {
                      context$3$0.next = 16;
                      break;
                    }

                    throw new Error('Could not find channel ' + channel);

                  case 16:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this7);
            })());

          case 15:

            if (options.websocket) {
              text = text.replace(/&/g, '&amp;').replace(/</, '&lt;').replace(/>/, '&gt;');
            } else {
              if (!options.icon_url && !options.icon_emoji) {
                options.icon_url = this.self.profile.image_original;
              }

              if (!options.username) {
                options.username = this.self.name;
              }
            }

            msg = _extends({
              channel: target,
              text: text }, options);
            method = msg.websocket ? 'message' : 'chat.postMessage';
            return context$2$0.abrupt('return', _modifiers2['default'].trigger('sendMessage', _extends({}, msg)).then(function () {
              return _this7.call(method, msg, msg.websocket);
            }));

          case 19:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }

    /**
     * Send a message with the specified user's avatar and name
     * There will still be a `bot` label near the name to indicate the message
     * is not originally from the user
     * @param  {String} user     username or id
     * @param  {String} channel  see `sendMessage`'s channel parameter
     * @param  {String} text     see `sendMessage`'s text parameter
     * @param  {Object} params   see `sendMessage`'s params parameter
     * @return {Promise}              A promise which resolves upon succes and fails
     *                                in case of errors
     */
  }, {
    key: 'sendAsUser',
    decorators: [(0, _modifiers.processable)('sendAsUser')],
    value: function sendAsUser(user, channel, text) {
      var params = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

      var u = this.find(user);
      var options = Object.assign({}, params, {
        username: u.name,
        icon_url: u.profile.image_48,
        as_user: false,
        websocket: false
      });

      return this.sendMessage(channel, text, options);
    }

    /**
     * Deletes a message
     * @param  {String} channel   the channel which the message was sent to
     * @param  {Number} timestamp timestamp of the message
     * @param  {Object} params
     * @return {Promise}          A promise which resolves upon succes and fails
     *                             in case of errors
     */
  }, {
    key: 'deleteMessage',
    decorators: [(0, _modifiers.processable)('deleteMessage')],
    value: function deleteMessage(channel, timestamp) {
      var _this8 = this;

      var params = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var target = this.find(channel);

      var msg = {
        channel: target.id, ts: timestamp
      };

      return _modifiers2['default'].trigger('deleteMessage', _extends({}, msg, params)).then(function () {
        return _this8.call('chat.delete', msg);
      });
    }

    /**
     * Updates a message
     * @param  {String} channel   the channel which the message was sent to
     * @param  {Number} timestamp timestamp of the message
     * @param  {String} text      the new text to replace the old one
     * @param  {Object} params    extra parameters
     * @return {Promise}          A promise which resolves upon succes and fails
     *                             in case of errors
     */
  }, {
    key: 'updateMessage',
    decorators: [(0, _modifiers.processable)('updateMessage')],
    value: function updateMessage(channel, timestamp, text) {
      var _this9 = this;

      var params = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

      var target = this.find(channel);

      var msg = _extends({
        channel: target.id, ts: timestamp,
        text: text }, params);

      return _modifiers2['default'].trigger('updateMessage', _extends({}, msg)).then(function () {
        return _this9.call('chat.update', msg);
      });
    }

    /**
     * Random helper which returns one of the provided arguments randomly
     * @param  {Mixed/Array} args a set of arguments which can contain flat arrays
     * @return {Mixed}
     */
  }, {
    key: 'random',
    decorators: [(0, _modifiers.processable)('random')],
    value: function random() {
      for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        args[_key5] = arguments[_key5];
      }

      var options = args.reduce(function (a, b) {
        return a.concat(b);
      }, []);

      var chance = 1 / (options.length - 1);

      var luck = +Math.random().toFixed(1);
      var index = Math.round(luck / chance);

      return options[index];
    }

    /**
     * List custom emojis of team
     * @return {Promise} A promise which resolves upon succes and fails
     *                             in case of errors
     */
  }, {
    key: 'emojis',
    decorators: [(0, _modifiers.processable)('emojis')],
    value: function emojis() {
      return this.call('emoji.list');
    }

    /**
     * Set bot's icon, can be either an :emoji: or a url
     * @param  {string} icon The icon to use, must be formatted like :emoji: to be
     *                       set as an emoji, otherwise will be considered as URL.
     *                       Pass a falsy value to delete the property
     * @return {Bot}         Returns the bot itself
     */
  }, {
    key: 'icon',
    decorators: [(0, _modifiers.processable)('icon')],
    value: function icon(_icon) {
      if (!_icon) {
        delete this.globals.icon_emoji;
        delete this.globals.icon_url;
        return this;
      }

      if (/:\w+:/.test(_icon)) {
        this.globals.icon_emoji = _icon;
      } else {
        this.globals.icon_url = _icon;
      }

      return this;
    }

    /**
     * Adds a reaction to a message
     * @param  {String} channel   the channel containing target message
     * @param  {Number} timestamp message's timestamp
     * @param  {String} emoji     reaction emoji, doesn't include colons
     *                            e.g. `rocket`
     * @param  {Object} params    extra parameters
     * @return {Promise}
     */
  }, {
    key: 'react',
    decorators: [(0, _modifiers.processable)('react')],
    value: function react(channel, timestamp, emoji) {
      var _this10 = this;

      var params = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

      var target = this.find(channel);

      var msg = _extends({
        channel: target.id,
        timestamp: timestamp, name: emoji }, params);

      return _modifiers2['default'].trigger('react', _extends({}, msg, params)).then(function () {
        return _this10.call('reactions.add', msg);
      });
    }

    /**
     * Calls the specified method with the parameters provided
     * @param  {String}  method     API method to call
     * @param  {Object}  params     parameters passed to the server
     * @param  {Boolean} websocket  indicates if the method should be called over websocket
     * @return {Promise}            A promise which resolves upon success and fails
     *                               in case of errors
     */
  }, {
    key: 'call',
    decorators: [(0, _modifiers.processable)('call')],
    value: function call(method) {
      var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var websocket = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

      var reply, api, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, key;

      return regeneratorRuntime.async(function call$(context$2$0) {
        var _this11 = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            if (!this.dead) {
              context$2$0.next = 2;
              break;
            }

            return context$2$0.abrupt('return');

          case 2:
            if (!websocket) {
              context$2$0.next = 15;
              break;
            }

            if (!(this.ws.readyState !== _ws2['default'].OPEN)) {
              context$2$0.next = 7;
              break;
            }

            this.queue.push({ method: method, params: params, websocket: websocket });
            this.reconnect();

            return context$2$0.abrupt('return');

          case 7:
            reply = this.waitForReply(id);

            try {
              this.ws.send(JSON.stringify(_extends({
                id: id++,
                type: method
              }, params)));
            } catch (e) {
              console.error('[slackbot-api]', this.ws.readyState, 'websocket send error:', e);
              this.reconnect();
            }

            context$2$0.t0 = {};
            context$2$0.t1 = params;
            context$2$0.next = 13;
            return regeneratorRuntime.awrap(reply);

          case 13:
            context$2$0.t2 = context$2$0.sent;
            return context$2$0.abrupt('return', _extends(context$2$0.t0, context$2$0.t1, context$2$0.t2));

          case 15:
            api = this._api || API;
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            context$2$0.prev = 19;
            // this.api is used in tests

            for (_iterator2 = Object.keys(params)[Symbol.iterator](); !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              key = _step2.value;

              if (typeof params[key] === 'object') {
                try {
                  params[key] = JSON.stringify(params[key]);
                } catch (e) {
                  // nevermind
                }
              }
            }

            context$2$0.next = 27;
            break;

          case 23:
            context$2$0.prev = 23;
            context$2$0.t3 = context$2$0['catch'](19);
            _didIteratorError2 = true;
            _iteratorError2 = context$2$0.t3;

          case 27:
            context$2$0.prev = 27;
            context$2$0.prev = 28;

            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }

          case 30:
            context$2$0.prev = 30;

            if (!_didIteratorError2) {
              context$2$0.next = 33;
              break;
            }

            throw _iteratorError2;

          case 33:
            return context$2$0.finish(30);

          case 34:
            return context$2$0.finish(27);

          case 35:
            return context$2$0.abrupt('return', new Promise(function (resolve, reject) {
              _unirest2['default'].get(api + method).headers({ Accept: 'application/json' }).query(params).query({ token: _this11.config.token }).end(function (response) {
                /* istanbul ignore next */
                if (response.statusType < 4 && response.body.ok) {
                  var msg = Object.assign({}, response.body, messageMethods(_this11));
                  resolve(msg);
                }
                /* istanbul ignore next */
                else reject(response.body);
              });
            }));

          case 36:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[19, 23, 27, 35], [28,, 30, 34]]);
    }

    /**
     * Wait for reply to the specified message id
     * @param  {Number} id message id
     * @return {Promise}
     */
  }, {
    key: 'waitForReply',
    decorators: [(0, _modifiers.processable)('waitForReply')],
    value: function waitForReply(messageId) {
      var _this12 = this;

      return new Promise(function (resolve, reject) {
        function listener(message) {
          if (message.reply_to === messageId) {
            this.removeListener('raw_message', listener);

            /* istanbul ignore if */
            if (typeof message.ok === 'undefined') return resolve(message);
            if (message.ok) return resolve(message);

            return reject(message);
          }
        }
        _this12.on('raw_message', listener);

        setTimeout(function () {
          _this12.removeListener('raw_message', listener);
        }, _this12.waitForReplyTimeout);
      });
    }

    /**
     * Detects if a string is representing id or name
     * @param  {String} string
     * @return {String}        returns 'ID' in case of an id and otherwise 'NAME'
     */
  }, {
    key: 'type',
    decorators: [(0, _modifiers.processable)('type')],
    value: function type(string) {
      var STARTINGS = ['U', 'C', 'G', 'D'];
      if (string.toUpperCase() === string && STARTINGS.indexOf(string[0]) > -1) {
        return 'ID';
      }

      return 'NAME';
    }

    /**
     * Stops the HTTP and WebSocket server and cleans up stuff
     */
  }, {
    key: 'destroy',
    value: function destroy() {
      if (this.ws && this.ws.stop) this.ws.terminate();
      clearInterval(this.pingIntv);
      this.dead = true;
    }
  }]);

  return Bot;
})(_events2['default']);

exports['default'] = Bot;

// should not listen on bots' messages

// don't include bot name in regex test

// Send a request and fetch Real-time Messaging API's websocket server

// @username sends the message to the users' @slackbot channel

// sending to users
