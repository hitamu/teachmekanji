"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.processable = processable;

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i]; return arr2; } else { return Array.from(arr); } }

var _modifiers = {};

var PREPROCESSOR = 0;
var POSTPROCESSOR = 1;
var MIDDLEWARE = 2;

exports["default"] = {
  /**
   * define a preprocessor filter, allowing it to modify the arguments passed
   * to a function by returning an array of arguments
   * @param  {String}   name modifier name
   * @param  {Function} fn   modifier function
   * @return {Number}        modifier index
   */
  preprocess: function preprocess(name, fn) {
    if (!_modifiers[name]) {
      _modifiers[name] = [];
    }

    var index = _modifiers[name].push({
      type: PREPROCESSOR, fn: fn
    });

    return index - 1;
  },

  /**
   * define a postprocessor modifier, allowing it to modify the return value of
   * a function by taking the return value as argument and passing the new
   * return value
   * @param  {String}   name modifier name
   * @param  {Function} fn   modifier function
   * @return {NUmber}        modifier index
   */
  postprocess: function postprocess(name, fn) {
    if (!_modifiers[name]) {
      _modifiers[name] = [];
    }

    var index = _modifiers[name].push({
      type: POSTPROCESSOR, fn: fn
    });

    return index - 1;
  },

  /**
   * define a middleware modifier, middlewares give you the flexibility to
   * modify a function's behavior by modifying / stopping a function from
   * completing it's job. For example you can register a middleware
   * on sendMessage to stop messages containing bad words from getting sent.
   *
   * Modifier functions are passed three arguments,
   * 	- context: The value getting processed by the function which includes
   * 	the information you should rely on to do your work
   *  - next: A function which continues calling middlewares until either all
   *  the middlewares pass and the actual function runs, or a middleware stops
   *  the chain. You can pass alternatively pass a promise to next for async
   *  tasks.
   *  - done: Stops the chain, preventing further middlewares and the function
   *  from running.
   * @param  {String}   name modifier name
   * @param  {Function} fn   function
   * @return {Number}        modifier index
   */
  middleware: function middleware(name, fn) {
    if (!_modifiers[name]) {
      _modifiers[name] = [];
    }

    var index = _modifiers[name].push({
      type: MIDDLEWARE, fn: fn
    });

    return index - 1;
  },

  /**
   * Trigger middlewares of a function
   * @param  {String} name    middleware name
   * @param  {Object} context The context object passed as first parameter to
   *                          middleware functions
   * @return {Promise}        indicates whether all the middlewares called next
   *                          (resolve) or not (reject)
   */
  trigger: function trigger(name, context) {
    var middlewares = (_modifiers[name] || []).filter(function (item) {
      return item.type === MIDDLEWARE;
    });

    return Promise.all(middlewares.map(function (middleware) {
      var fn = middleware.fn;

      return fn(context);
    }));
  },

  /**
   * Remove a postprocessor/preprocessor modifier
   * @param  {String} name  modifier name
   * @param  {Number} index modifier index
   */
  remove: function remove(name, index) {
    _modifiers[name].splice(index, 1);
  },

  /**
   * Clears all modifiers
   */
  clear: function clear() {
    _modifiers = {};
  },

  /**
   * Returns the modifiers object
   * @return {Object} modifiers object
   */
  modifiers: function modifiers() {
    return _modifiers;
  }
};

/**
 * A decorator which modifies a function to be processable, allowing
 * preprocessors and postprocessors to modify
 * the arguments and/or the return value of the function
 * @param  {String} name modifier name
 * @return {Function}    decorator
 */

function processable(name) {
  return function decorator(target, key, descriptor) {
    var originalFunction = descriptor.value;
    descriptor.value = function fn() {
      var list = _modifiers[name] || [];

      var preprocessors = list.filter(function (item) {
        return item.type === PREPROCESSOR;
      });
      var postprocessors = list.filter(function (item) {
        return item.type === POSTPROCESSOR;
      });

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var filteredArgs = preprocessors.reduce(function (modified, modifier) {
        return modifier.fn.apply(modifier, _toConsumableArray(modified));
      }, args);

      var value = originalFunction.apply(this, filteredArgs);

      var filteredValue = postprocessors.reduce(function (modified, modifier) {
        return modifier.fn(modified);
      }, value);

      return filteredValue;
    };
  };
}
